package org.drools.validation

import java.util.ArrayList;
import java.util.HashMap;

import org.drools.verifier.components.Definition;
import org.drools.verifier.components.ObjectType;
import org.drools.verifier.components.LiteralRestriction;
import org.drools.verifier.components.Pattern;
import org.drools.verifier.report.components.Severity;
import org.drools.verifier.report.components.VerifierMessage;
import org.drools.verifier.report.components.MessageType;

import org.drools.verifier.data.VerifierReport
import org.drools.verifier.components.Field;

global VerifierReport result;

rule "Missing Definition for ObjectType"
    when
        $objectType : ObjectType( $typeName : name )
        not Definition( typeName == $typeName )
    then
        result.add(new VerifierMessage(
                        new HashMap(),
                        Severity.ERROR,
                        MessageType.MISSING_COMPONENT,
                        $objectType,
                        "Missing type definition for fact type: " + $typeName
                        ,
                        new ArrayList() ) );
end

declare FinalField
    patternName: String
    fieldName: String
end

declare Split
    patternName: String
    fieldName: String
    leftOver: String[]
end

rule "Split"
    when
        LiteralRestriction( fieldPath != null, $fieldName : fieldName, $patternName : patternName )
    then
        if($fieldName.contains(".")) {
            Split split = new Split();

            String[] array = $fieldName.split("\\.");
            split.setFieldName(array[0]);
            split.setPatternName( $patternName );
            split.setLeftOver( java.util.Arrays.copyOfRange(array, 1, array.length) );
            insert( split );
        } else {
            FinalField ff = new FinalField();
            ff.setPatternName( $patternName );
            ff.setFieldName( $fieldName );
            insert( ff );
        }
end

rule "Trim split"
    when
        $split :Split( $fieldName :fieldName, eval( leftOver.length > 0) )
        $definition : Definition( typeName == $split.patternName, fieldNames contains $fieldName)
    then
        String fieldType = $definition.getDeclaredFields().get($fieldName);
        String[] oldArray = $split.getLeftOver();
        String[] newArray = java.util.Arrays.copyOfRange(oldArray, 1, oldArray.length);
        $split.setFieldName(oldArray[0]);
        $split.setPatternName( fieldType );
        $split.setLeftOver( newArray );
        update( $split );

end

rule "Add final field"
    when
        Split( $patternName : patternName, $fieldName : fieldName, eval( leftOver.length == 0))
    then
        FinalField ff = new FinalField();
        ff.setPatternName( $patternName );
        ff.setFieldName( $fieldName );
        insert( ff );
end

rule "Missing Field in Definition"
    when
        $restriction : FinalField( $fieldName : fieldName )
        $definition : Definition( typeName == $restriction.patternName, fieldNames not contains $fieldName )
    then
        result.add(new VerifierMessage(
                          new HashMap(),
                          Severity.ERROR,
                          MessageType.MISSING_COMPONENT,
                          $definition,
                          "Field '" + $fieldName  + "' used in rule but not declared in definition of type '" + $restriction.getPatternName() + "'",
                          new ArrayList() ) );
end

rule "Missing Field in a missing Definition"
    when
        $restriction : FinalField( $fieldName : fieldName )
        not Definition( typeName == $restriction.patternName )
    then
        result.add(new VerifierMessage(
                          new HashMap(),
                          Severity.ERROR,
                          MessageType.MISSING_COMPONENT,
                          null,
                          "Field '" + $fieldName  + "' used in rule but not declared in definition of type '" + $restriction.getPatternName() + "'",
                          new ArrayList() ) );
end

rule "Error when Definition exists, but it is lacking a field"
    when
        $split :Split( $fieldName :fieldName, $patternName :patternName)
        $definition : Definition( typeName == $split.patternName, fieldNames not contains $split.fieldName)
    then
          result.add(new VerifierMessage(
                              new HashMap(),
                              Severity.ERROR,
                              MessageType.MISSING_COMPONENT,
                              null,
                              "Field '" + $fieldName  + "' used in rule but not declared in definition of type '" + $patternName + "'",
                              new ArrayList() ) );
end
